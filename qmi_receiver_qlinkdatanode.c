#include <pthread.h>#include <errno.h>#include <string.h>#include <unistd.h>#include <qmi.h>#include <qmi_client.h>#include <qmi_idl_lib.h>#include <device_management_service_v01.h>#include <user_identity_module_v01.h>#include <network_access_service_v01.h>#include "qmi_parser_qlinkdatanode.h"#include "qmi_common_qlinkdatanode.h"#include "common_qlinkdatanode.h"#include "feature_macro_qlinkdatanode.h"#ifndef FEATURE_ENABLE_QMI_RECVER_qlinkdatanode_C_LOG#define LOG print_to_null#endiftypedef struct {  qmi_client_error_type dms_result;  qmi_client_error_type uim_result;  qmi_client_error_type nas_result;  qmi_client_error_type dms_result_2;}Qmi_Result_S_Type;/******************************External Variables*******************************/extern QMI_Msg_Config qmi_msg_config;extern int DMS_wr_fd;extern unsigned long thread_id_array[THD_IDX_MAX];/******************************Local Variables*******************************/static pthread_t qmi_receiver_tid;static pthread_mutex_t receiver_mutex = PTHREAD_MUTEX_INITIALIZER;static pthread_cond_t receiver_cond = PTHREAD_COND_INITIALIZER;static int receiverStarted = 0;/******************************Global Variables*******************************/int qmi_handle = QMI_INVALID_CLIENT_HANDLE;qmi_client_type dms_client_handle = NULL;qmi_client_type uim_client_handle = NULL;qmi_client_type nas_client_handle = NULL;qmi_client_type dms_client_handle_2 = NULL;qmi_idl_service_object_type dms_service_object;qmi_idl_service_object_type uim_service_object;qmi_idl_service_object_type nas_service_object;qmi_idl_service_object_type dms_service_object_2;void Qmi_receive_release(void){      qmi_client_release(dms_client_handle);      qmi_client_release(uim_client_handle);      qmi_client_release(nas_client_handle);      qmi_client_release(dms_client_handle_2);      qmi_release(qmi_handle);}static void dms_ind_cb(qmi_client_type user_handle,                            unsigned long msg_id,                            unsigned char *ind_buf,                            int ind_buf_len,                            void *ind_cb_data){  int ret = -1;  char buf=0;  if(user_handle == NULL){    LOG("ERROR: user_handle is empty.\n");    goto __EXIT_OF_IND_CB__;  }    if(ind_buf==NULL || ind_buf_len<=0){    LOG("ERROR: ind_buf is empty.\n");    goto __EXIT_OF_IND_CB__;  }  LOG("msg_id=%lu, len=%d.\n", msg_id, ind_buf_len);    init_qmi_msg_config(&qmi_msg_config);    qmi_msg_config.user_handle = user_handle;  qmi_msg_config.msg_id = msg_id;  qmi_msg_config.msg_type = QMI_IDL_INDICATION;  qmi_msg_config.raw_data_len = ind_buf_len;  qmi_msg_config.raw_data_buf = malloc(qmi_msg_config.raw_data_len);  memset(qmi_msg_config.raw_data_buf, 0, qmi_msg_config.raw_data_len);  memcpy(qmi_msg_config.raw_data_buf, ind_buf, qmi_msg_config.raw_data_len);  do{    if(ret == 0){      LOG("write() failed. ret=%d.\n", ret);    }    ret = write(DMS_wr_fd, &buf, 1);  }while ((ret<0 && (errno==EINTR || errno==EAGAIN)) || (ret==0));  //Not care the result, but keep listening to the QMI DMS.  if(ret < 0){    LOG("ERROR: write() failed. ret=%d. errno=%d.\n", ret, errno);  }__EXIT_OF_IND_CB__:  return;}static void uim_ind_cb(qmi_client_type user_handle,                                 unsigned long msg_id,                                 unsigned char *ind_buf,                                 int ind_buf_len,                                 void *ind_cb_data){}static void nas_ind_cb(qmi_client_type user_handle,                            unsigned long msg_id,                            unsigned char *ind_buf,                            int ind_buf_len,                            void *ind_cb_data){}static void dms_ind_cb_2(qmi_client_type user_handle,                             unsigned long msg_id,                             unsigned char *ind_buf,                             int ind_buf_len,                             void *ind_cb_data){}static void *initReceiver(void *user_data){  qmi_client_error_type dms_result, uim_result, nas_result, dms_result_2;  dms_service_object = dms_get_service_object_v01();  uim_service_object = uim_get_service_object_v01();  nas_service_object = nas_get_service_object_v01();  dms_service_object_2 = dms_get_service_object_v01();  dms_result = qmi_client_init("rmnet0",                               dms_service_object,                               dms_ind_cb,                               dms_service_object,                               &dms_client_handle);  ((Qmi_Result_S_Type *)user_data)->dms_result = dms_result;  uim_result = qmi_client_init("rmnet0",                              uim_service_object,                              uim_ind_cb,                              uim_service_object,                              &uim_client_handle);  ((Qmi_Result_S_Type *)user_data)->uim_result = uim_result;  nas_result = qmi_client_init("rmnet0",                              nas_service_object,                              nas_ind_cb,                              nas_service_object,                              &nas_client_handle);  ((Qmi_Result_S_Type *)user_data)->nas_result = nas_result;  dms_result_2 = qmi_client_init("rmnet0",                               dms_service_object_2,                               dms_ind_cb_2,                               dms_service_object_2,                               &dms_client_handle_2);  ((Qmi_Result_S_Type *)user_data)->dms_result_2 = dms_result_2;  pthread_mutex_lock(&receiver_mutex);  receiverStarted = 1;  pthread_cond_broadcast(&receiver_cond);  pthread_mutex_unlock(&receiver_mutex);  if (dms_result != QMI_NO_ERR     || uim_result != QMI_NO_ERR     || nas_result != QMI_NO_ERR    || dms_result_2 != QMI_NO_ERR  )  {    LOG("ERROR: qmi_client_init() error. "      "dms_result=%d, uim_result=%d, nas_result=%d, dms_result_2=%d.\n",      dms_result, uim_result, nas_result, dms_result_2);    if (qmi_handle >=0 ){       qmi_client_release(dms_client_handle);      qmi_client_release(uim_client_handle);      qmi_client_release(nas_client_handle);      qmi_client_release(dms_client_handle_2);      qmi_release(qmi_handle);    }    return NULL;  }  while(1){    sleep(0x00ffffff);  }  LOG("ERROR: QMI receiver ended unexpectedly!\n");  return NULL;}//return value:// 0: error// 1: successint startQMIReceiverThread(void){  int ret;  pthread_attr_t attr;    Qmi_Result_S_Type result = {    .dms_result = QMI_NO_ERR,    .uim_result = QMI_NO_ERR,    .nas_result = QMI_NO_ERR,    .dms_result_2 = QMI_NO_ERR  };  qmi_handle = qmi_init(NULL, NULL);  if (qmi_handle < 0)  {    LOG("qmi_init() error.\n.");    return 0;  }  receiverStarted = 0;    pthread_mutex_lock(&receiver_mutex);  pthread_attr_init (&attr);  pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);  #ifdef FEATURE_ENABLE_SYSTEM_RESTORATION  pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, NULL);  pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, NULL);#endif__QMI_RECVER_PTHREAD_CREATE_AGAIN__:  ret = pthread_create(&qmi_receiver_tid, &attr, initReceiver, (void *)(&result));  if(ret != 0){    if(EAGAIN == errno){      sleep(1);      goto __QMI_RECVER_PTHREAD_CREATE_AGAIN__;    }    LOG("ERROR: pthread_create() failed. errno=%d.\n", errno);    return 0;  }  thread_id_array[THD_IDX_RECVER] = (unsigned long)qmi_receiver_tid;  while(receiverStarted == 0){    pthread_cond_wait(&receiver_cond, &receiver_mutex);  }  pthread_mutex_unlock(&receiver_mutex);  if(result.dms_result != QMI_NO_ERR     || result.uim_result != QMI_NO_ERR     || result.nas_result != QMI_NO_ERR    || result.dms_result_2 != QMI_NO_ERR  )  {    LOG("ERROR: qmi_client_init() error."        "dms_result=%d, uim_result=%d, nas_result=%d, dms_result_2=%d.\n",    result.dms_result, result.uim_result, result.nas_result, result.dms_result_2);    return 0;  }  return 1;}