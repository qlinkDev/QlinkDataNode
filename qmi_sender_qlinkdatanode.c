#include <pthread.h>#include <errno.h>#include <stdlib.h>#include <string.h>#include <sys/select.h>#include <unistd.h>#include <fcntl.h>#include <qmi.h>#include <qmi_client.h>#include <device_management_service_v01.h>#include <user_identity_module_v01.h>#include "qmi_sender_qlinkdatanode.h"#include "common_qlinkdatanode.h"#include "protocol_qlinkdatanode.h"#include "feature_macro_qlinkdatanode.h"#include "at_qlinkdatanode.h"#include "socket_qlinkdatanode.h"#ifndef FEATURE_ENABLE_QMI_SENDER_qlinkdatanode_C_LOG#define LOG print_to_null#endif/******************************External Functions*******************************/extern void print_fmt_data(char *str);extern void msq_send_imsi_ind_internal(void);#ifdef FEATURE_ENABLE_SYSTEM_RESTORATIONextern void notify_RstMonitor(char msg);#endif/******************************External Variables*******************************/extern bool isOnlineMode;extern bool isUploadImsiToOtherProc;extern int qmi_handle;extern qmi_client_type dms_client_handle;extern qmi_client_type uim_client_handle;extern rsmp_recv_buffer_s_type g_rsmp_recv_buffer;extern Dev_Info rsmp_dev_info;extern pthread_mutex_t log_file_mtx;extern unsigned long thread_id_array[THD_IDX_MAX];extern APDU_Setting APDU_setting;extern bool isEnableManualApdu;extern unsigned char  g_is7100modemstartfail;#define MAX_BYTES_SEND_TO_QMI_ONCE (512)#ifdef FEATURE_ENABLE_CONTRL_EmodemREBOOT_0117DEBUGextern unsigned char g_is7100modem_register_state;#endif#ifdef FEATURE_ENABLE_OUT_OF_TRAFFIC_AND_DATE_0206	extern bool isCancelRecoveryNet;#endif  /******************************Local Variables*******************************/static pthread_t qmi_sender_tid;static pthread_mutex_t sender_mutex = PTHREAD_MUTEX_INITIALIZER;static pthread_cond_t sender_cond = PTHREAD_COND_INITIALIZER;static int senderStarted = 0;static int sender_pipe_rd_fd = -1;/******************************Global Variables*******************************/int sender_pipe_wr_fd = -1;//Description://	The var below are all for synchronizing thread.//	When apply uim with powerup and powerdown action, these vars are useful for handling //	possible timeout of setting uim powerup or powerdown.// 1. For powerupbool isUimActed = false;pthread_mutex_t act_uim_mtx = PTHREAD_MUTEX_INITIALIZER;pthread_cond_t act_uim_cond = PTHREAD_COND_INITIALIZER;// 2. For powerdownbool isRstingUsim = false;bool isUimRstOperCplt = false;pthread_mutex_t rst_uim_mtx = PTHREAD_MUTEX_INITIALIZER;pthread_cond_t rst_uim_cond = PTHREAD_COND_INITIALIZER;// 3. For rst RF//Description://isRstRf is to request sender_set_operation_mode to notify requester that operation mode is set.bool isRstRf = false;bool isRfRsted = false;pthread_mutex_t rst_rf_mtx = PTHREAD_MUTEX_INITIALIZER;pthread_cond_t rst_rf_cond = PTHREAD_COND_INITIALIZER;//Description://If UIM is set power down by app, it will be set true. Otherwise, it is false.bool isUimPwrDwn = false;//Receive the message is "simcard not avaiable", it will be set true. Otherwise, it is false.bool isUimPwrDwnMssage = false;bool isAutoReprotPowerDown = false;pthread_mutex_t notifySender_mutex = PTHREAD_MUTEX_INITIALIZER;bool isEnableApduSenderMtx = false;//Description://		Once one thread acquired apdu_sender_mtx and wait for "cond" signal in pthread_cond_wait(),//	the apdu_sender_mtx is unlocked implicitly at that moment. And other threads are able to acquire //	apdu_sender_mtx at that time. So, apdu_sender_mtx is unable to synchronize threads. In order to//	synchronize threads, we apply isApduSenderMtxLocked to do that.bool isApduSenderMtxLocked = false;pthread_mutex_t apdu_sender_mtx = PTHREAD_MUTEX_INITIALIZER;pthread_cond_t apdu_sender_cond = PTHREAD_COND_INITIALIZER;pthread_mutex_t apdu_mtx = PTHREAD_MUTEX_INITIALIZER; // 20160304 jacklibool isApduSentToMdm = false;static void do_write_simdata(void){  unsigned int size = 0;  unsigned int total_count = 0;  unsigned int count = 0;  unsigned int remainder;  qmi_client_error_type rc;  dms_vsm_write_pkt_data_req_msg_v01   req_msg;  dms_vsm_write_pkt_data_resp_msg_v01  resp_msg;  if(dms_client_handle == NULL){    LOG("ERROR: dms_client_handle = null!\n");    return;  }    if(g_rsmp_recv_buffer.data == NULL){    LOG("ERROR: buffer_config.data is empty.\n");    return;  }  size = g_rsmp_recv_buffer.size;  total_count = size/MAX_BYTES_SEND_TO_QMI_ONCE;  remainder = size%MAX_BYTES_SEND_TO_QMI_ONCE;  if(remainder > 0)     total_count+=1;  LOG("remainder =%u. size=%u. total_count=%u.\n", remainder, size, total_count);	for(; count<total_count; count++){		LOG("No.%d time to send data to QMI.\n", count+1);	    memset(&req_msg, 0, sizeof(req_msg));		memset(&resp_msg, 0, sizeof(resp_msg));	// fix bug: Download SIMcard data fail when the vaule of remainder is 0.(by jack li 20160225)	        if( total_count == (count+1) )        {		if (0 == remainder)		{			req_msg.pkt_data.data_len = MAX_BYTES_SEND_TO_QMI_ONCE;		}		else		{			req_msg.pkt_data.data_len = remainder;		}	 }	else{	    	req_msg.pkt_data.data_len = MAX_BYTES_SEND_TO_QMI_ONCE;	}		        memcpy(req_msg.pkt_data.data, (unsigned char *)(g_rsmp_recv_buffer.data)+MAX_BYTES_SEND_TO_QMI_ONCE*count, req_msg.pkt_data.data_len );				LOG("Length of sending data=%d.\n", req_msg.pkt_data.data_len);				#ifdef FEATURE_ENABLE_SENDER_DISPATCHED_REMOTE_UIM_DATA_LOG		{			#ifndef FEATURE_DEBUG_QXDM				#ifndef FEATURE_DEBUG_LOG_FILE					int i = 0;					LOG("App -> QMI: ");					for(; i<req_msg.pkt_data.data_len; i++){						LOG2("%02x ", *((unsigned char *)(g_rsmp_recv_buffer.data)+MAX_BYTES_SEND_TO_QMI_ONCE*count+i) );					}					LOG2("\n");				#else					#error code not present				#endif			#else				#error code not present			#endif		}		#endif // FEATURE_ENABLE_SENDER_DISPATCHED_REMOTE_UIM_DATA_LOG		    print_cur_gm_time("   QMISENDER (WRITE SIM data)   ");    rc = qmi_client_send_msg_sync(dms_client_handle,                                QMI_DMS_VSM_WRITE_PKT_DATA_REQ_V01,                                &req_msg,                                sizeof(req_msg),                                &resp_msg,                                sizeof(resp_msg),                                15000);    if(rc != QMI_NO_ERR){      LOG("ERROR: Failed to write No.%d time of simdata. rc=%d.\n", count+1, rc);      return;    }  }  LOG("Sending remote USIM data to mdm completes.\n");  return;}static void do_response_tpdu(void){  unsigned int size = 0;  unsigned int total_count = 0;  unsigned int count = 0;  unsigned int remainder;  qmi_client_error_type rc;  dms_vsm_write_apdu_data_req_msg_v01   req_msg;  dms_vsm_write_apdu_data_resp_msg_v01  resp_msg;  void * rsp_data = NULL;  #ifdef FEATURE_NEW_APDU_COMM  APDU_Setting *as = &APDU_setting;  unsigned char procedure_apdursp[2] = {0x61, 0x00};#endif //FEATURE_NEW_APDU_COMM  if(dms_client_handle == NULL){    LOG("ERROR: dms_client_handle = null!\n");    return;  }  if(g_rsmp_recv_buffer.data == NULL){    LOG("ERROR: g_rsmp_recv_buffer.data is empty.\n");    return;  }#ifdef  FEATURE_ENABLE_CANCEL_LOG_OUTPUT  //20160708  LOG("Test: the status var value 007 isEnableManualApdu  = %d.\n", isEnableManualApdu );#endif	 if(as->is2GCard)	{		procedure_apdursp[0] = 0x9F;	}#ifdef FEATURE_NEW_APDU_COMM  if(!isEnableManualApdu)  { #ifdef  FEATURE_ENABLE_CANCEL_LOG_OUTPUT  //20160708    LOG("test:the status var value 08 as->proc_step =%d.\n", as->proc_step);#endif    if(2 == as->proc_step)    {      if(g_rsmp_recv_buffer.size <= 0x03)      {        LOG("the server apdu rsp size is not enough %d!\n", g_rsmp_recv_buffer.size );        procedure_apdursp[0] = 0x98;        procedure_apdursp[1] = 0x62;		if(as->is2GCard)		{			procedure_apdursp[1] = 0x04;		}        rsp_data = procedure_apdursp;        size = 2;      }else      {        procedure_apdursp[1] = g_rsmp_recv_buffer.size - 0x03; //think over 0:C0         rsp_data = procedure_apdursp;        size = 2;      }    }else if( 1 == as->proc_step)    {      rsp_data = g_rsmp_recv_buffer.data;      size = g_rsmp_recv_buffer.size;    }else // proc_step ?    {      rsp_data = g_rsmp_recv_buffer.data;       ((unsigned char *)(rsp_data))[0] = as->head_byte;//should C0 here      size = g_rsmp_recv_buffer.size;    }  }else  { //apdu timeout process...    rsp_data = g_rsmp_recv_buffer.data;    size = g_rsmp_recv_buffer.size;  } #ifdef  FEATURE_ENABLE_CANCEL_LOG_OUTPUT //20160708   LOG("Test: the status var value 12 isEnableManualApdu  = %d.\n", isEnableManualApdu );#endif  #else  rsp_data = g_rsmp_recv_buffer.data;   size = g_rsmp_recv_buffer.size;#endif    total_count = size/MAX_BYTES_SEND_TO_QMI_ONCE;  remainder = size%MAX_BYTES_SEND_TO_QMI_ONCE;    if(remainder > 0)    total_count+=1;  LOG("size=%u. total_count=%u.\n", size, total_count);  for(; count<total_count; count++)  {    memset(&req_msg, 0, sizeof(req_msg));    memset(&resp_msg, 0, sizeof(resp_msg));    if( total_count == (count+1) )      req_msg.apdu_data.data_len = remainder;    else      req_msg.apdu_data.data_len = MAX_BYTES_SEND_TO_QMI_ONCE;    memcpy(req_msg.apdu_data.data, (unsigned char *)(rsp_data)+MAX_BYTES_SEND_TO_QMI_ONCE*count, req_msg.apdu_data.data_len );#ifdef FEATURE_ENABLE_SENDER_DISPATCHED_APDU_LOG		{			#ifndef FEATURE_DEBUG_QXDM				#ifndef FEATURE_DEBUG_LOG_FILE					int i = 0;					LOG("QMISENDER: ");					for(; i<req_msg.apdu_data.data_len; i++){						LOG2("%02x ", *((unsigned char *)rsp_data+MAX_BYTES_SEND_TO_QMI_ONCE*count+i) );					}					LOG2("\n");				#else					int i = 1;										pthread_mutex_lock(&log_file_mtx);					LOG2("QMISENDER: \n");					for(; i<=req_msg.apdu_data.data_len; i++){						if(i%20 == 1)							LOG4(" %02x", 										get_byte_of_void_mem(rsp_data, MAX_BYTES_SEND_TO_QMI_ONCE*count+i-1) );						else							LOG3(" %02x", 										get_byte_of_void_mem(rsp_data, MAX_BYTES_SEND_TO_QMI_ONCE*count+i-1) );												if(i%20 == 0) //Default val of i is 1							LOG3("\n");					}					if((i-1)%20 != 0) // Avoid print redundant line break						LOG3("\n");					pthread_mutex_unlock(&log_file_mtx);				#endif /*FEATURE_DEBUG_LOG_FILE*/			#else				int i = 0;				int data_len = req_msg.apdu_data.data_len;				int buf_len = 3*data_len+1;				char buf[buf_len];								memset(buf, 0, buf_len);				for(; i < data_len; i++){					sprintf(buf+i*3, "%02x ", *((unsigned char *)(rsp_data)+MAX_BYTES_SEND_TO_QMI_ONCE*count+i) );				}				LOG("QMISENDER: ");				#ifdef FEATURE_ENABLE_FMT_PRINT_DATA_LOG					print_fmt_data(buf);				#else					LOG2("  %s", buf);				#endif			#endif		}#endif // FEATURE_ENABLE_SENDER_DISPATCHED_APDU_LOG    rc = qmi_client_send_msg_sync(dms_client_handle,                                  QMI_DMS_VSM_WRITE_APDU_DATA_REQ_V01,                                  &req_msg,                                  sizeof(req_msg),                                  &resp_msg,                                  sizeof(resp_msg),                                  15000);    if(rc != QMI_NO_ERR || resp_msg.resp.result != QMI_RESULT_SUCCESS_V01){      LOG("ERROR: qmi_client_send_msg_sync() failed. rc=%d, resp_msg.resp.error=%d.\n", rc, resp_msg.resp.error);#ifdef FEATURE_ENABLE_REBOOT_DEBUG	LOG("ERROR: QMI error system reboot.\n");	//system("reboot");	yy_popen_call("reboot -f");#endif      count --;      //Retry    }  }//end for  #ifdef  FEATURE_ENABLE_CANCEL_LOG_OUTPUT  //20160708  LOG("test:the status var value 09 isEnableApduSenderMtx=%d, isApduSentToMdm=%d.\n", isEnableApduSenderMtx, isApduSentToMdm);#endif    pthread_mutex_lock(&apdu_sender_mtx);  isApduSentToMdm = true;  pthread_cond_broadcast(&apdu_sender_cond);  pthread_mutex_unlock(&apdu_sender_mtx);#ifdef  FEATURE_ENABLE_CANCEL_LOG_OUTPUT  //20160708  LOG("test:the status var value 11 isEnableApduSenderMtx=%d, isApduSentToMdm=%d.\n", isEnableApduSenderMtx, isApduSentToMdm);#endif }//Param://	mode://		0x00: Online mode.//		0x01: LPM.static void do_set_operation_mode(const int mode){	qmi_client_error_type rc;	dms_set_operating_mode_req_msg_v01   req_msg;	dms_set_operating_mode_resp_msg_v01  resp_msg;	if(dms_client_handle == NULL){		LOG("ERROR: dms_client_handle is unavailable!\n");		return;	}	if(mode < 0x00 || mode > 0x01){		LOG("ERROR: Operation mode 0x%02x not supported!\n", mode);		return;	}	if(mode == 0x01){		LOG("ERROR: LPM is not supported in sender_set_operation_mode(). Please utilize QMI DMS sender to implement LPM.\n");		return;	}	req_msg.operating_mode = mode;		print_cur_gm_time("   QMISENDER (Set oper mode)   ");	rc = qmi_client_send_msg_sync(dms_client_handle, 																QMI_DMS_SET_OPERATING_MODE_REQ_V01,																&req_msg,																sizeof(req_msg),																&resp_msg,																sizeof(resp_msg),																300000);	if(rc != QMI_NO_ERR || resp_msg.resp.result != QMI_RESULT_SUCCESS_V01){		LOG("ERROR: qmi_client_send_msg_sync() failed. rc=%d, resp_msg.resp.error=%d.\n", rc, resp_msg.resp.error);	}else{		if(mode == DMS_OP_MODE_ONLINE_V01){			isOnlineMode = true;		}else if(mode == DMS_OP_MODE_LOW_POWER_V01){			isOnlineMode = false;		}				if(isRstRf){			isRstRf = false; //Rst						pthread_mutex_lock(&rst_rf_mtx);			isRfRsted = true;			pthread_cond_broadcast(&rst_rf_cond);			pthread_mutex_unlock(&rst_rf_mtx);		}				LOG("Setting operation mode 0x%02x completes.\n", mode);#ifdef FEATURE_ENABLE_REBOOT_DEBUG		g_is7100modemstartfail = 1;		LOG("Debug: g_is7100modemstartfail = %d.\n", g_is7100modemstartfail);#endif#ifdef FEATURE_ENABLE_CONTRL_EmodemREBOOT_0117DEBUG 	       g_is7100modem_register_state = 1;		LOG("Debug: g_is7100modem_register_state = %d.\n", g_is7100modem_register_state);#endif	}	return;}static void do_uim_power_up(void){  qmi_client_error_type rc;  uim_power_up_req_msg_v01 req_msg;  uim_power_up_resp_msg_v01 resp_msg;  if(uim_client_handle == NULL){    LOG("ERROR: uim_client_handle is unavailable!\n");    return;  }  req_msg.slot = UIM_SLOT_1_V01;  print_cur_gm_time("   QMISENDER  (Set uim power up)   ");  rc = qmi_client_send_msg_sync(uim_client_handle,                                QMI_UIM_POWER_UP_REQ_V01,                                &req_msg,                                sizeof(req_msg),                                &resp_msg,                                sizeof(resp_msg),                                15000);  if(rc != QMI_NO_ERR || resp_msg.resp.result != QMI_RESULT_SUCCESS_V01){    LOG("ERROR: qmi_client_send_msg_sync() failed. rc=%d, resp_msg.resp.error=%d.\n", rc, resp_msg.resp.error);  }else{    LOG("Setting uim power up completes.\n");  }  return;}extern void go_to_next_state_after_recving_IMSI(void);extern void send_id_auth_msg_after_recving_IMSI(void);extern bool isSendIdAfterAcqIMSI;static void do_acq_imsi(void){  qmi_client_error_type rc;  dms_acq_imsi_of_virt_uim_resp_msg_v01  resp_msg;  memset(rsmp_dev_info.IMSI, 0, IMSI_DATA_LEN);  print_cur_gm_time("   QMISENDER (Acq IMSI)   ");  rc = qmi_client_send_msg_sync(dms_client_handle,                                QMI_DMS_ACQ_IMSI_OF_VIRT_UIM_REQ_V01,                                NULL,                                0,                                &resp_msg,                                sizeof(resp_msg),                                15000);	if(rc != QMI_NO_ERR || resp_msg.resp.result != QMI_RESULT_SUCCESS_V01){		LOG("ERROR: qmi_client_send_msg_sync() failed. rc=%d, resp_msg.resp.error=%d.\n", rc, resp_msg.resp.error);#ifdef FEATURE_ENABLE_REBOOT_DEBUG	LOG("ERROR: QMI error system reboot.\n");	//system("reboot");	yy_popen_call("reboot -f");#endif	}else{		#ifdef FEATURE_ENABLE_PRINT_ACQ_IMSI		{			#ifndef FEATURE_DEBUG_QXDM				#ifndef FEATURE_DEBUG_LOG_FILE					int i = 0;									LOG("The acquired IMSI: ");					for(; i<IMSI_DATA_LEN; i++){						LOG2("%02x ", resp_msg.imsi[i]);					}					LOG2("\n");				#else					int i = 1;										pthread_mutex_lock(&log_file_mtx);					LOG2("The acquired IMSI: \n");					for(; i<=IMSI_DATA_LEN; i++){						if(i == 1)							LOG4(" %02x", resp_msg.imsi[i-1]);						else							LOG3(" %02x", resp_msg.imsi[i-1]);					}					LOG3("\n");					pthread_mutex_unlock(&log_file_mtx);				#endif /*FEATURE_DEBUG_LOG_FILE*/			#else				int i = 0;				int data_len = IMSI_DATA_LEN;				int buf_len = 3*data_len+1;				char buf[buf_len];								memset(buf, 0, buf_len);				for(; i < data_len; i++){					sprintf(buf+i*3, "%02x ", resp_msg.imsi[i]);				}				LOG("The acquired IMSI: ");				#ifdef FEATURE_ENABLE_FMT_PRINT_DATA_LOG					print_fmt_data(buf);				#else					LOG2("  %s", buf);				#endif			#endif		}		#endif				if((resp_msg.imsi)[0] == 0x00)			memset(rsmp_dev_info.IMSI, 0, IMSI_DATA_LEN);		else			memcpy(rsmp_dev_info.IMSI, resp_msg.imsi, IMSI_DATA_LEN);				if(isUploadImsiToOtherProc){			LOG("isUploadImsiToOtherProc=1, so upload qry IMSI to other proc.\n");			isUploadImsiToOtherProc = false;						msq_send_imsi_ind_internal();			goto __EXIT_OF_SENDER_ACQ_IMSI__;		}				if(!isSendIdAfterAcqIMSI){			go_to_next_state_after_recving_IMSI();		}else{			isSendIdAfterAcqIMSI = false; // Not necessary. Following ID auth all need it to be true.			send_id_auth_msg_after_recving_IMSI();		}	}	__EXIT_OF_SENDER_ACQ_IMSI__:  return;}static void do_del_simdata(void){  qmi_client_error_type rc;  dms_del_virt_usim_data_resp_msg_v01 resp_msg;  print_cur_gm_time("   QMISENDER  (Del Virt USIM)   ");  rc = qmi_client_send_msg_sync(dms_client_handle,                                QMI_DMS_DEL_VIRT_USIM_DATA_REQ_V01,                                NULL,                                0,                                &resp_msg,                                sizeof(resp_msg),                                15000);  if(rc != QMI_NO_ERR || resp_msg.resp.result != QMI_RESULT_SUCCESS_V01){    LOG("ERROR: qmi_client_send_msg_sync() failed. rc=%d, resp_msg.resp.error=%d.\n", rc, resp_msg.resp.error);  }  return;}//Param://	0x00: APDU//	0x01: remote USIM data//	0x02: set oper mode online//	0x03: acq IMSI//	0x04: (Abandoned!) set oper mode offline//	0x05: del local virt USIM data//  0x03 and 0x05 are all required in r_acqDataHdlr().//Notice://	Please set flow_info.flow_state before calling notify_Sender().void notify_Sender(qmisender_request_type opt){  int n = -1;  pthread_mutex_lock(&notifySender_mutex);  if(opt < QMISENDER_MIN || opt > QMISENDER_MAX){    LOG("ERROR: Wrong param input. opt=%02x.\n", opt);    goto __EXIT_OF_NOTIFY_SENDER__;  }  LOG("Test: the status var value 08 opt= %d.\n", opt );  do{    if(n == 0)      LOG("write() failed. n=%d.\n", n);        n = write(sender_pipe_wr_fd, (void *)(&opt), sizeof(qmisender_request_type));  }while ((n<0 && errno==EINTR) || n==0);    if(n<0){    LOG("ERROR: write() failed. n=%d. errno=%s(%d).\n", n, strerror(errno), errno);    LOG("Test: the status var value 05 n  = %d.\n", n );	  }__EXIT_OF_NOTIFY_SENDER__:   LOG6("~~~~notify_Sender: %d\n", opt);#ifdef FEATURE_NEW_APDU_COMM  if(opt == QMISENDER_RESPONSE_TPDU)  {    LOG6("Test:APDU_setting.proc_step as step = %d\n", APDU_setting.proc_step);  }#endif  pthread_mutex_unlock(&notifySender_mutex);}void SenderLoop(void){  int n;  int fdp1;  fd_set rfd;  qmisender_request_type buf = -1;    FD_ZERO(&rfd);  FD_SET(sender_pipe_rd_fd, &rfd);  fdp1 = sender_pipe_rd_fd+1;  for(;;)  {    n = select(fdp1, &rfd, NULL, NULL, NULL);    if (n < 0){      if (errno == EINTR) continue;      LOG("select() error. errno=%s(%d).\n", strerror(errno), errno);      continue;    }else if(n == 0)      continue;        do{      n = read(sender_pipe_rd_fd, &buf, sizeof(buf));    }while ((n<0 && errno==EINTR) || (n == 0));     LOG("Test: the status var value 06 buf  = %d.\n", buf );    if(QMISENDER_RESPONSE_TPDU == buf)    {       pthread_mutex_lock(&apdu_mtx); // 20160304 jackli      do_response_tpdu();      pthread_mutex_unlock(&apdu_mtx);    }else if(QMISENDER_WRITE_SIMDATA == buf)    {      do_write_simdata();    }else if(QMISENDER_SET_ONLINE == buf)    {      if(isUimPwrDwn)      {#ifdef FEATURE_ENABLE_OUT_OF_TRAFFIC_AND_DATE_0206	LOG("Debug:   isCancelRecoveryNet = %d \n",isCancelRecoveryNet);	if (isCancelRecoveryNet != true){		do_uim_power_up();			}else{		LOG("Debug:   Don't neet to power up for out of traffic \n");	}#else	          do_uim_power_up();#endif#ifdef FEATURE_ENABLE_SYSTEM_RESTORATION        notify_RstMonitor(0x01);        sleep(1);#endif      }      if(false == isOnlineMode)      {        do_set_operation_mode(DMS_OP_MODE_ONLINE_V01);      }else{        LOG("ERROR: Set operation mode 0x00, but isOnlineMode = true.\n");      }      if(isUimPwrDwn)      {        isUimPwrDwn = false;        pthread_mutex_lock(&act_uim_mtx);        isUimActed = true;        pthread_cond_broadcast(&act_uim_cond);        pthread_mutex_unlock(&act_uim_mtx);      }    }else if(QMISENDER_ACQ_IMSI == buf)    {      do_acq_imsi();    }else if(QMISENDER_SET_OFFLINE == buf)    {      do_set_operation_mode(DMS_OP_MODE_LOW_POWER_V01);    }else if(QMISENDER_DEL_SIMDATA == buf){      do_del_simdata();    }else{      LOG("ERROR: wrong qmisender_request_type.\n");    }    LOG("QMI sender completes. buf=%d.\n", buf);  }  LOG("ERROR: Unexpected error. SenderLoop() ended.\n");  return;}static void *initSender(void *user_data){  int ret;  int sender_pipe[2];  ret = pipe(sender_pipe);  *((int *)user_data) = ret;  pthread_mutex_lock(&sender_mutex);  senderStarted = 1;  pthread_cond_broadcast(&sender_cond);  pthread_mutex_unlock(&sender_mutex);  if (ret < 0) {    LOG("pipe() error. errno=%d.\n", errno);    return NULL;  }    sender_pipe_wr_fd = sender_pipe[1];  sender_pipe_rd_fd = sender_pipe[0];  fcntl(sender_pipe_rd_fd, F_SETFL, O_NONBLOCK);  SenderLoop();  LOG("ERROR: SenderLoop() ended unexpectedly!\n");    while(1){    sleep(0x00ffffff);  }      return NULL;}//return value://	0: error//	1: successint startQMISender(void){  int ret;  pthread_attr_t attr;  qmi_client_error_type result;  if(qmi_handle == QMI_INVALID_CLIENT_HANDLE){    LOG("ERROR: qmi_handle doesn't exist.\n");    return 0;  }    if(dms_client_handle == NULL){    LOG("ERROR: dms_client_handle doesn't exist.\n");    return 0;  }  senderStarted = 0;  pthread_mutex_lock(&sender_mutex);  pthread_attr_init (&attr);  pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);    #ifdef FEATURE_ENABLE_SYSTEM_RESTORATION  pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, NULL);  pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, NULL);#endif__QMI_SENDER_PTHREAD_CREATE_AGAIN__:  ret = pthread_create(&qmi_sender_tid, &attr, initSender, (void *)(&result));  if(ret != 0){    if(EAGAIN == errno){      sleep(1);      goto __QMI_SENDER_PTHREAD_CREATE_AGAIN__;    }    LOG("ERROR: pthread_create() failed. errno=%d.\n", errno);    return 0;  }  thread_id_array[THD_IDX_SENDER] = (unsigned long)qmi_sender_tid;  while(senderStarted == 0){    pthread_cond_wait(&sender_cond, &sender_mutex);  }  pthread_mutex_unlock(&sender_mutex);  if(result < 0){    LOG("ERROR: initSender() error.\n.");    return 0;  }  return 1;}